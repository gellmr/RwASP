using Microsoft.AspNetCore.Mvc;
using ReactWithASP.Server.Domain;
using ReactWithASP.Server.Domain.Abstract;
using ReactWithASP.Server.DTO;
using ReactWithASP.Server.Infrastructure;
using System.Security.Claims;

namespace ReactWithASP.Server.Controllers
{
  public abstract class ShopController : MyBaseController
  {
    protected enum UserType { Guest, AppUser, GoogleAppUser, None };

    protected IGuestRepository guestRepo;
    protected ICartLineRepository cartLineRepo;
    protected IInStockRepository inStockRepo;
    protected Microsoft.AspNetCore.Identity.UserManager<AppUser> _userManager;

    public ShopController(ICartLineRepository rRepo, IGuestRepository gRepo, IInStockRepository pRepo, Microsoft.AspNetCore.Identity.UserManager<AppUser> userManager) {
      guestRepo = gRepo;
      cartLineRepo = rRepo;
      inStockRepo = pRepo;
      _userManager = userManager;
    }

    protected void DeleteGuestCookie(){
      HttpContext.Response.Cookies.Delete(MyExtensions.GuestCookieName);
    }

    protected string? GetLoggedInUserIdFromIdentityCookie()
    {
      string? uid = User.Identity.IsAuthenticated ? User.FindFirstValue(ClaimTypes.NameIdentifier) : null;
      return uid;
    }

    // Fetches a Guest object from the database, creating if necessary.
    // Generates the Guest ID if it does not already exist.
    // If you pass a Guest object as argument, its values (if not null) will overwrite the ones that are in the database.
    // If you pass a Guest object will all null values except Email, only the Email value will be used to overwrite.
    // The Guest ID gets saved to the cookie before we return the finalised Guest object.
    protected Guest EnsureGuestFromCookieAndDb(Guest? updateDto)
    {
      // // If we have a currently logged in AppUser then return immediately.
      // string? uid = GetLoggedInUserIdFromIdentityCookie();
      // if (!string.IsNullOrEmpty(uid))
      // {
      //   //DeleteGuestCookie(); // Dont delete
      //   return null;
      // }

      // The Guest ID is generated by our server, and saved to the DB before we ever send it to the user's cookie.
      // So we never need to update the ID.

      Guest guest = new Guest();

      // See if guest ID cookie exists...
      string cookieGuestId = Request.Cookies[MyExtensions.GuestCookieName];
      if (string.IsNullOrEmpty(cookieGuestId))
      {
        // Could not get ID from cookie. We will create it in a moment...
      }
      else
      {
        // Got an ID from the cookie...
        guest.ID = cookieGuestId.ToGuid();
      }

      // Do we need to generate the ID for the first time ?
      if (guest.ID == null)
      {
        guest.ID = Guid.NewGuid();
      }

      // Use transaction to avoid race condition.
      // If a second request comes later, it will have to await.
      using (var transaction = guestRepo.BeginTransaction())
      {
        try
        {
          //    Look up the guest in the database within the transaction.
          //    The database will lock this record to prevent other concurrent
          //    transactions from modifying it until this one is complete.
          Guest dbGuest = guestRepo.Guests.FirstOrDefault(g => g.ID.Equals(guest.ID));
          if (dbGuest != null)
          {
            // There was a record in the database...
            guest.Email     = dbGuest.Email;
            guest.FirstName = dbGuest.FirstName;
            guest.LastName  = dbGuest.LastName;
          }

          //    Update the guest object with incoming DTO values.
          if (updateDto != null)
          {
            guest.Email     = updateDto.Email     ?? guest.Email;
            guest.FirstName = updateDto.FirstName ?? guest.FirstName;
            guest.LastName  = updateDto.LastName  ?? guest.LastName;
          }

          //    Persist the updated data to the database.
          //    This save is part of the transaction and won't be finalized
          //    until we commit.
          guestRepo.SaveGuest(guest);

          //    Commit the transaction.
          //    This is where all changes are made permanent and the database lock is released.
          transaction.Commit();
        }
        catch (Exception ex)
        {
          // If anything goes wrong, rollback the transaction.
          // The database will revert to the state it was in before the transaction began.
          transaction.Rollback();
          throw; // Re-throw the exception so you can handle it upstream.
        }
      }

      //    Persist ID to cookie.
      //    This happens after a successful database commit.
      DeleteGuestCookie();
      Response.Cookies.Append(MyExtensions.GuestCookieName, guest.ID.ToString(), MyExtensions.CookieOptions);

      //    Return the finalized guest object.
      return guest;
    }
  }
}